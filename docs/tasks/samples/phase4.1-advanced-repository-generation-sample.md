# Phase 4.1: Repository Generation Sample

> **‚ö†Ô∏è PLANNED FEATURE**: This sample describes functionality planned for Phase 4.1. Source generator-based repository generation is not yet implemented in NPA. This document serves as a design reference and future implementation guide.

## üìã Task Overview

**Objective**: Demonstrate source generator capabilities for automatic Dapper-based repository creation from interfaces.

**Priority**: High  
**Estimated Time**: 6-8 hours  
**Dependencies**: Phase 4.1 (Repository Generation) - **NOT YET IMPLEMENTED**  
**Target Framework**: .NET 8.0  
**Sample Name**: RepositoryGenerationSample  
**Status**: üìã Planned for Phase 4

## üéØ Success Criteria

- [ ] Generates repository implementations from interfaces
- [ ] Supports custom query methods by naming convention
- [ ] Generates CRUD methods automatically
- [ ] Includes complex query generation
- [ ] Shows IntelliSense support
- [ ] Demonstrates incremental generation
- [ ] Provides generated code visibility

## üìù Repository Definition

### 1. Basic Repository Interface
```csharp
[GenerateRepository]
public interface ICustomerRepository
{
    // Generated: Basic CRUD
    Task<Customer?> FindByIdAsync(long id);
    Task<IEnumerable<Customer>> FindAllAsync();
    Task SaveAsync(Customer customer);
    Task UpdateAsync(Customer customer);
    Task DeleteAsync(long id);
    
    // Generated: Query methods by naming convention
    Task<Customer?> FindByEmailAsync(string email);
    Task<IEnumerable<Customer>> FindByIsActiveAsync(bool isActive);
    Task<IEnumerable<Customer>> FindByFirstNameAndLastNameAsync(string firstName, string lastName);
    Task<IEnumerable<Customer>> FindByCreatedAtBetweenAsync(DateTime start, DateTime end);
    
    // Generated: Count and exists methods
    Task<long> CountAsync();
    Task<long> CountByIsActiveAsync(bool isActive);
    Task<bool> ExistsByEmailAsync(string email);
    
    // Generated: Delete methods
    Task<int> DeleteByIsActiveAsync(bool isActive);
    
    // Generated: Pagination
    Task<IEnumerable<Customer>> FindAllAsync(int page, int pageSize);
    Task<IEnumerable<Customer>> FindByIsActiveAsync(bool isActive, int page, int pageSize);
}
```

### 2. Generated Implementation
```csharp
// Auto-generated by NPA.Generators
public class CustomerRepository : ICustomerRepository
{
    private readonly IEntityManager _entityManager;
    
    public CustomerRepository(IEntityManager entityManager)
    {
        _entityManager = entityManager;
    }
    
    public async Task<Customer?> FindByIdAsync(long id)
    {
        return await _entityManager.FindAsync<Customer>(id);
    }
    
    public async Task<IEnumerable<Customer>> FindAllAsync()
    {
        return await _entityManager.CreateQuery<Customer>()
            .GetResultListAsync();
    }
    
    public async Task<Customer?> FindByEmailAsync(string email)
    {
        return await _entityManager.CreateQuery<Customer>()
            .Where("Email = @email")
            .SetParameter("email", email)
            .GetSingleResultAsync();
    }
    
    public async Task<IEnumerable<Customer>> FindByFirstNameAndLastNameAsync(
        string firstName, string lastName)
    {
        return await _entityManager.CreateQuery<Customer>()
            .Where("FirstName = @firstName AND LastName = @lastName")
            .SetParameter("firstName", firstName)
            .SetParameter("lastName", lastName)
            .GetResultListAsync();
    }
    
    public async Task<IEnumerable<Customer>> FindByCreatedAtBetweenAsync(
        DateTime start, DateTime end)
    {
        return await _entityManager.CreateQuery<Customer>()
            .Where("CreatedAt >= @start AND CreatedAt <= @end")
            .SetParameter("start", start)
            .SetParameter("end", end)
            .GetResultListAsync();
    }
    
    public async Task<long> CountByIsActiveAsync(bool isActive)
    {
        return await _entityManager.CreateQuery<Customer>()
            .Where("IsActive = @isActive")
            .SetParameter("isActive", isActive)
            .ExecuteScalarAsync<long>("COUNT(*)");
    }
    
    // ... other generated methods
}
```

## üíª Naming Conventions

| Method Pattern | Generated Query |
|----------------|-----------------|
| `FindBy{Property}` | `WHERE Property = @value` |
| `FindBy{Prop1}And{Prop2}` | `WHERE Prop1 = @val1 AND Prop2 = @val2` |
| `FindBy{Prop1}Or{Prop2}` | `WHERE Prop1 = @val1 OR Prop2 = @val2` |
| `FindBy{Property}Between` | `WHERE Property >= @start AND Property <= @end` |
| `FindBy{Property}LessThan` | `WHERE Property < @value` |
| `FindBy{Property}GreaterThan` | `WHERE Property > @value` |
| `FindBy{Property}Like` | `WHERE Property LIKE @pattern` |
| `FindBy{Property}In` | `WHERE Property IN @values` |
| `CountBy{Property}` | `SELECT COUNT(*) WHERE Property = @value` |
| `ExistsBy{Property}` | `SELECT EXISTS WHERE Property = @value` |
| `DeleteBy{Property}` | `DELETE WHERE Property = @value` |

## üîß Generator Configuration

```csharp
// GeneratorConfig.cs
[assembly: NpaRepositoryGeneration(
    GenerateCrud = true,
    GenerateAsync = true,
    GeneratePagination = true,
    IncludeComments = true,
    Namespace = "MyApp.Repositories.Generated"
)]
```

## üìä Performance Benefits

- **Compile-Time Generation** - Zero runtime overhead
- **Type Safety** - Full IntelliSense support
- **Consistency** - Standard implementation patterns
- **Productivity** - 80% less boilerplate code
- **Maintainability** - Generated code is always up-to-date

## üìö Learning Outcomes

- Source generator concepts
- Roslyn API usage
- Incremental generation
- Code generation patterns
- Convention over configuration
- Compile-time metaprogramming

---

*Created: October 8, 2025*  
*Status: ‚è≥ Pending*
