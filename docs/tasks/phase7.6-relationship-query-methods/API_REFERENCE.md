# Relationship Query Methods - API Reference

## Overview

This document provides a complete API reference for all relationship query methods generated by the NPA repository generator. These methods enable you to query entities based on their relationships with other entities.

## Table of Contents

1. [ManyToOne Relationship Queries](#manytoone-relationship-queries)
2. [OneToMany Relationship Queries](#onetomany-relationship-queries)
3. [Property-Based Queries](#property-based-queries)
4. [Advanced Filters](#advanced-filters)
5. [Complex Filters](#complex-filters)
6. [Multi-Level Navigation](#multi-level-navigation)
7. [Aggregate Methods](#aggregate-methods)
8. [Pagination and Sorting](#pagination-and-sorting)

---

## ManyToOne Relationship Queries

### FindBy{Property}IdAsync

Find entities by their related entity's ID (foreign key).

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindBy{Property}IdAsync(TKey id)
Task<IEnumerable<TEntity>> FindBy{Property}IdAsync(TKey id, int skip, int take)
Task<IEnumerable<TEntity>> FindBy{Property}IdAsync(TKey id, int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find all orders for customer with ID 123
var orders = await orderRepository.FindByCustomerIdAsync(123);

// With pagination
var ordersPage = await orderRepository.FindByCustomerIdAsync(123, skip: 0, take: 10);

// With sorting
var ordersSorted = await orderRepository.FindByCustomerIdAsync(
    123, 
    skip: 0, 
    take: 10, 
    orderBy: "TotalAmount", 
    ascending: false
);
```

**SQL Generated:**
```sql
SELECT * FROM orders 
WHERE customer_id = @id 
ORDER BY id
OFFSET @skip ROWS FETCH NEXT @take ROWS ONLY
```

---

### CountBy{Property}IdAsync

Count entities by their related entity's ID.

**Signature:**
```csharp
Task<int> CountBy{Property}IdAsync(TKey id)
```

**Example:**
```csharp
// Count orders for customer 123
var count = await orderRepository.CountByCustomerIdAsync(123);
```

**SQL Generated:**
```sql
SELECT COUNT(*) FROM orders WHERE customer_id = @id
```

---

## OneToMany Relationship Queries

### Has{Property}Async

Check if an entity has any related children.

**Signature:**
```csharp
Task<bool> Has{Property}Async(TKey id)
```

**Example:**
```csharp
// Check if customer has any orders
var hasOrders = await customerRepository.HasOrdersAsync(123);
```

**SQL Generated:**
```sql
SELECT COUNT(*) FROM orders WHERE customer_id = @id
-- Returns true if count > 0
```

---

### Count{Property}Async

Count the number of related children.

**Signature:**
```csharp
Task<int> Count{Property}Async(TKey id)
```

**Example:**
```csharp
// Count orders for customer 123
var orderCount = await customerRepository.CountOrdersAsync(123);
```

**SQL Generated:**
```sql
SELECT COUNT(*) FROM orders WHERE customer_id = @id
```

---

### FindWith{Property}Async

Find parent entities that have related children.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindWith{Property}Async()
Task<IEnumerable<TEntity>> FindWith{Property}Async(int skip, int take)
Task<IEnumerable<TEntity>> FindWith{Property}Async(int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find all customers who have placed orders
var customersWithOrders = await customerRepository.FindWithOrdersAsync();
```

**SQL Generated:**
```sql
SELECT c.* FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.customer_id = c.id
)
```

---

### FindWithout{Property}Async

Find parent entities that have no related children.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindWithout{Property}Async()
Task<IEnumerable<TEntity>> FindWithout{Property}Async(int skip, int take)
Task<IEnumerable<TEntity>> FindWithout{Property}Async(int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find all customers with no orders
var customersWithoutOrders = await customerRepository.FindWithoutOrdersAsync();
```

**SQL Generated:**
```sql
SELECT c.* FROM customers c
WHERE NOT EXISTS (
    SELECT 1 FROM orders o WHERE o.customer_id = c.id
)
```

---

### FindWith{Property}CountAsync

Find parent entities that have at least a specified number of related children.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindWith{Property}CountAsync(int minCount)
Task<IEnumerable<TEntity>> FindWith{Property}CountAsync(int minCount, int skip, int take)
Task<IEnumerable<TEntity>> FindWith{Property}CountAsync(int minCount, int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find customers with at least 5 orders
var vipCustomers = await customerRepository.FindWithOrdersCountAsync(5);
```

**SQL Generated:**
```sql
SELECT c.* FROM customers c
WHERE (
    SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id
) >= @minCount
```

---

## Property-Based Queries

### FindBy{Property}{PropertyName}Async

Find entities by properties of their related entity using JOIN queries.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindBy{Property}{PropertyName}Async(TPropertyType propertyValue)
Task<IEnumerable<TEntity>> FindBy{Property}{PropertyName}Async(TPropertyType propertyValue, int skip, int take)
Task<IEnumerable<TEntity>> FindBy{Property}{PropertyName}Async(TPropertyType propertyValue, int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find orders by customer name
var orders = await orderRepository.FindByCustomerNameAsync("John Doe");

// With pagination and sorting
var ordersPage = await orderRepository.FindByCustomerNameAsync(
    "John Doe",
    skip: 0,
    take: 20,
    orderBy: "OrderDate",
    ascending: false
);
```

**SQL Generated:**
```sql
SELECT o.* FROM orders o
INNER JOIN customers c ON o.customer_id = c.id
WHERE c.name = @name
ORDER BY o.id
```

**Note:** Methods are generated for all simple properties of the related entity (excluding primary keys and relationships).

---

## Advanced Filters

### Date Range Filters

#### FindBy{Property}And{PropertyName}RangeAsync

Find entities by related entity ID and a date range on a DateTime property of the current entity.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindBy{Property}And{PropertyName}RangeAsync(
    TKey id, 
    DateTime? startDate, 
    DateTime? endDate)
Task<IEnumerable<TEntity>> FindBy{Property}And{PropertyName}RangeAsync(
    TKey id, 
    DateTime? startDate, 
    DateTime? endDate, 
    int skip, 
    int take, 
    string? orderBy, 
    bool ascending)
```

**Example:**
```csharp
// Find orders for customer 123 placed between two dates
var orders = await orderRepository.FindByCustomerAndOrderDateRangeAsync(
    123,
    startDate: DateTime.UtcNow.AddDays(-30),
    endDate: DateTime.UtcNow
);
```

**SQL Generated:**
```sql
SELECT * FROM orders
WHERE customer_id = @id
  AND order_date >= @startDate
  AND order_date <= @endDate
ORDER BY id
```

---

### Amount/Quantity Filters

#### Find{Property}{PropertyName}AboveAsync

Find parent entities where a numeric property of related children exceeds a threshold.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> Find{Property}{PropertyName}AboveAsync(TNumericType threshold)
Task<IEnumerable<TEntity>> Find{Property}{PropertyName}AboveAsync(TNumericType threshold, int skip, int take)
Task<IEnumerable<TEntity>> Find{Property}{PropertyName}AboveAsync(TNumericType threshold, int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find customers with total order amount above $1000
var vipCustomers = await customerRepository.FindCustomerTotalAmountAboveAsync(1000m);
```

**SQL Generated:**
```sql
SELECT c.* FROM customers c
WHERE (
    SELECT COALESCE(SUM(o.total_amount), 0) FROM orders o 
    WHERE o.customer_id = c.id
) >= @threshold
```

---

### Subquery-Based Filters

#### FindWithMinimum{Property}Async

Find parent entities that have at least a minimum number of related children.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindWithMinimum{Property}Async(int minimum)
Task<IEnumerable<TEntity>> FindWithMinimum{Property}Async(int minimum, int skip, int take)
Task<IEnumerable<TEntity>> FindWithMinimum{Property}Async(int minimum, int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find customers with at least 10 orders
var activeCustomers = await customerRepository.FindWithMinimumOrdersAsync(10);
```

**SQL Generated:**
```sql
SELECT c.* FROM customers c
WHERE (
    SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id
) >= @minimum
```

---

## Complex Filters

### OR Combinations

#### FindBy{Property1}Or{Property2}Async

Find entities that match either of two relationship criteria.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindBy{Property1}Or{Property2}Async(TKey? id1, TKey? id2)
Task<IEnumerable<TEntity>> FindBy{Property1}Or{Property2}Async(TKey? id1, TKey? id2, int skip, int take)
Task<IEnumerable<TEntity>> FindBy{Property1}Or{Property2}Async(TKey? id1, TKey? id2, int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find orders for customer 123 OR supplier 456
var orders = await orderRepository.FindByCustomerOrSupplierAsync(123, 456);
```

**SQL Generated:**
```sql
SELECT * FROM orders
WHERE customer_id = @customerId OR supplier_id = @supplierId
ORDER BY id
```

**Note:** Parameters are nullable, allowing one side of the OR to be null.

---

### AND Combinations

#### FindBy{Property}And{PropertyName}Async

Find entities that match both a relationship criterion and an entity property.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindBy{Property}And{PropertyName}Async(TKey id, TPropertyType propertyValue)
Task<IEnumerable<TEntity>> FindBy{Property}And{PropertyName}Async(TKey id, TPropertyType propertyValue, int skip, int take)
Task<IEnumerable<TEntity>> FindBy{Property}And{PropertyName}Async(TKey id, TPropertyType propertyValue, int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find orders for customer 123 with status "Pending"
var pendingOrders = await orderRepository.FindByCustomerAndStatusAsync(123, "Pending");
```

**SQL Generated:**
```sql
SELECT * FROM orders
WHERE customer_id = @customerId AND status = @status
ORDER BY id
```

---

## Multi-Level Navigation

### FindBy{IntermediateEntity}{Property}{PropertyName}Async

Navigate through multiple relationship levels to find entities based on a distant related entity's property.

**Signature:**
```csharp
Task<IEnumerable<TEntity>> FindBy{IntermediateEntity}{Property}{PropertyName}Async(TPropertyType propertyValue)
Task<IEnumerable<TEntity>> FindBy{IntermediateEntity}{Property}{PropertyName}Async(TPropertyType propertyValue, int skip, int take)
Task<IEnumerable<TEntity>> FindBy{IntermediateEntity}{Property}{PropertyName}Async(TPropertyType propertyValue, int skip, int take, string? orderBy, bool ascending)
```

**Example:**
```csharp
// Find order items for orders belonging to customer "John Doe" (2-level navigation)
var items = await orderItemRepository.FindByOrderCustomerNameAsync("John Doe");

// Find order items for customers in "New York" (3-level navigation)
var items = await orderItemRepository.FindByOrderCustomerAddressCityAsync("New York");
```

**SQL Generated (2-level):**
```sql
SELECT oi.* FROM order_items oi
INNER JOIN orders o ON oi.order_id = o.id
INNER JOIN customers c ON o.customer_id = c.id
WHERE c.name = @name
ORDER BY oi.id
```

**SQL Generated (3-level):**
```sql
SELECT oi.* FROM order_items oi
INNER JOIN orders o ON oi.order_id = o.id
INNER JOIN customers c ON o.customer_id = c.id
INNER JOIN addresses a ON c.id = a.customer_id
WHERE a.city = @city
ORDER BY oi.id
```

**Supported Navigation Depths:**
- ✅ 2 levels (e.g., OrderItem → Order → Customer)
- ✅ 3+ levels (e.g., OrderItem → Order → Customer → Address)
- ✅ All relationship types (ManyToOne, OneToOne, ManyToMany)

---

## Aggregate Methods

### Numeric Property Aggregates

#### GetTotal{Property}{PropertyName}Async

Sum a numeric property across all related children.

**Signature:**
```csharp
Task<TNumericType> GetTotal{Property}{PropertyName}Async(TKey id)
```

**Example:**
```csharp
// Get total amount of all orders for customer 123
var total = await customerRepository.GetTotalOrdersTotalAmountAsync(123);
```

**SQL Generated:**
```sql
SELECT COALESCE(SUM(o.total_amount), 0) FROM orders o 
WHERE o.customer_id = @id
```

---

#### GetAverage{Property}{PropertyName}Async

Calculate the average of a numeric property across related children.

**Signature:**
```csharp
Task<double> GetAverage{Property}{PropertyName}Async(TKey id)
```

**Example:**
```csharp
// Get average order amount for customer 123
var average = await customerRepository.GetAverageOrdersTotalAmountAsync(123);
```

---

#### GetMin{Property}{PropertyName}Async / GetMax{Property}{PropertyName}Async

Find minimum/maximum values of a numeric property.

**Signature:**
```csharp
Task<TNumericType?> GetMin{Property}{PropertyName}Async(TKey id)
Task<TNumericType?> GetMax{Property}{PropertyName}Async(TKey id)
```

---

### GROUP BY Aggregates

#### Get{Property}CountsBy{ParentEntity}Async

Count related children grouped by parent entity (returns Dictionary).

**Signature:**
```csharp
Task<Dictionary<TKey, int>> Get{Property}CountsBy{ParentEntity}Async()
```

**Example:**
```csharp
// Get order counts grouped by customer ID
var counts = await customerRepository.GetOrdersCountsByCustomerAsync();
// Returns: Dictionary<int, int> where key is customer ID, value is order count
```

**SQL Generated:**
```sql
SELECT customer_id, COUNT(*) as count
FROM orders
GROUP BY customer_id
```

---

#### Get{ParentEntity}{Property}SummaryAsync

Multi-entity GROUP BY with JOINs - returns parent entity properties along with aggregates.

**Signature:**
```csharp
Task<IEnumerable<(TEntity Parent, int Count, TNumericType? Total, double? Average)>> 
    Get{ParentEntity}{Property}SummaryAsync()
```

**Example:**
```csharp
// Get customer summary with order statistics
var summaries = await customerRepository.GetCustomerOrdersSummaryAsync();
foreach (var (customer, count, total, average) in summaries)
{
    Console.WriteLine($"Customer {customer.Name}: {count} orders, Total: {total}, Avg: {average}");
}
```

**SQL Generated:**
```sql
SELECT 
    c.*,
    COUNT(o.id) as count,
    COALESCE(SUM(o.total_amount), 0) as total,
    AVG(o.total_amount) as average
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
GROUP BY c.id, c.name, c.email
```

---

## Pagination and Sorting

### Pagination Parameters

All collection query methods support pagination through `skip` and `take` parameters:

```csharp
Task<IEnumerable<TEntity>> MethodAsync(..., int skip, int take)
```

- **skip**: Number of records to skip (0-based)
- **take**: Maximum number of records to return

**Example:**
```csharp
// Get second page (records 10-19)
var page2 = await orderRepository.FindByCustomerIdAsync(123, skip: 10, take: 10);
```

---

### Sorting Parameters

All pagination overloads support configurable sorting:

```csharp
Task<IEnumerable<TEntity>> MethodAsync(..., int skip, int take, string? orderBy, bool ascending)
```

- **orderBy**: Property name to sort by (uses `[Column]` attribute mapping)
- **ascending**: Sort direction (true = ascending, false = descending)

**Example:**
```csharp
// Get orders sorted by total amount (descending)
var orders = await orderRepository.FindByCustomerIdAsync(
    123,
    skip: 0,
    take: 10,
    orderBy: "TotalAmount",
    ascending: false
);
```

**Security Note:** The `orderBy` parameter is validated against a compile-time property-to-column mapping dictionary to prevent SQL injection.

---

## Return Types

### Collection Methods
- Return `Task<IEnumerable<TEntity>>` for entity collections
- All results are materialized (not deferred execution)

### Count Methods
- Return `Task<int>` for counts

### Existence Methods
- Return `Task<bool>` for existence checks

### Aggregate Methods
- Return `Task<TNumericType>` for SUM
- Return `Task<double>` for AVG
- Return `Task<TNumericType?>` for MIN/MAX (nullable if no records)
- Return `Task<Dictionary<TKey, int>>` for grouped counts
- Return `Task<IEnumerable<Tuple>>` for multi-entity summaries

---

## Null Handling

- **Nullable relationship parameters**: OR combination methods accept nullable IDs
- **Null FK values**: Methods correctly handle null foreign keys in WHERE clauses
- **Empty collections**: COUNT methods return 0, existence methods return false
- **No matches**: Collection methods return empty enumerable (not null)

---

## Performance Considerations

### Query Optimization
- ✅ Direct WHERE clauses (no unnecessary JOINs for ID-based queries)
- ✅ Efficient COUNT queries for existence checks
- ✅ Single query per method call (no N+1 problems)
- ✅ Proper JOIN conditions using correct column names from `[Column]` attributes

### Index Recommendations
- Create indexes on foreign key columns for optimal performance
- Consider composite indexes for frequently queried property combinations
- Monitor query execution plans for large datasets

---

## Error Handling

Methods throw standard exceptions:
- **InvalidOperationException**: If repository dependencies are not properly initialized
- **SqlException**: Database-level errors (connection issues, constraint violations, etc.)
- **ArgumentNullException**: If required parameters are null (where not nullable)

---

## See Also

- [Query Optimization Guidelines](OPTIMIZATION_GUIDE.md)
- [Relationship Query Patterns and Best Practices](PATTERNS_AND_BEST_PRACTICES.md)
- [Performance Best Practices](PERFORMANCE_GUIDE.md)
- [Examples for Common Scenarios](EXAMPLES.md)
- [Troubleshooting Guide](TROUBLESHOOTING.md)
- [Migration Guide](MIGRATION_GUIDE.md)

